# プロジェクト開発ルール

## アーキテクチャ

このプロジェクトはクリーンアーキテクチャとDDD（ドメイン駆動設計）に基づいています。

### レイヤー構造

```
Presentation → Application → Domain
                    ↓
              Infrastructure
```

### 依存関係の原則

1. **外側の層は内側の層に依存できる**が、**内側の層は外側に依存してはいけない**
2. **ドメイン層は完全に独立**している（外部依存を持たない）
3. インフラ層の実装詳細は**インターフェースで抽象化**する
4. 依存性注入を使って具体的な実装を注入する

### 各層の責務

#### Domain Layer（ドメイン層）
- **責務**: ビジネスロジックの中核
- **含むもの**: エンティティ、値オブジェクト、ドメインサービス、リポジトリインターフェース
- **禁止事項**: 
  - 外部ライブラリへの依存（ORMやHTTPフレームワークなど）
  - データベースやAPIへの直接アクセス
  - 他の層への依存

#### Application Layer（アプリケーション層）
- **責務**: ユースケースの実装、ビジネストランザクションの調整
- **含むもの**: ユースケース、DTO
- **依存可能**: Domain層のみ
- **禁止事項**:
  - データベースの実装詳細への依存
  - HTTPリクエスト/レスポンスオブジェクトへの直接アクセス

#### Infrastructure Layer（インフラストラクチャ層）
- **責務**: 外部システムとの連携の実装
- **含むもの**: リポジトリの実装、データベースアクセス、外部API呼び出し
- **依存可能**: Domain層、Application層
- **実装時の注意**:
  - Domain層で定義されたインターフェースを実装する
  - ORM固有の型をDomain層に漏らさない

#### Presentation Layer（プレゼンテーション層）
- **責務**: HTTP通信の処理
- **含むもの**: コントローラー、ルーティング、DTOマッパー
- **依存可能**: Application層、Domain層
- **実装時の注意**:
  - リクエスト/レスポンスの変換のみを行う
  - ビジネスロジックを書かない

## コーディング規約

### TypeScript

1. **型安全性を最大限に活用**
   - `any`の使用を避ける
   - 適切な型定義を行う
   - 戻り値の型を明示的に書く

2. **Null安全性**
   - `null` / `undefined` を明示的に扱う
   - Optional Chaining (`?.`) を活用する

3. **命名規則**
   - クラス名: PascalCase
   - 関数・変数: camelCase
   - 定数: UPPER_SNAKE_CASE
   - インターフェース: `I` プレフィックスは不要

### エラーハンドリング

1. **ドメインエラーを定義**
   - ビジネスルール違反は`DomainError`を継承したカスタムエラーを使用
   - エラーメッセージは分かりやすく具体的に

2. **エラーの伝播**
   - 下位層で発生したエラーは適切に上位層に伝える
   - 必要に応じてエラーをラップする

### テスト

1. **テストの作成**
   - ユニットテストを書く（特にドメイン層とアプリケーション層）
   - テストファイルは `*.test.ts` の命名規則

2. **テストの方針**
   - ビジネスロジックは必ずテストする
   - モックを使って外部依存を排除
   - テストケースは分かりやすい名前をつける

### バリデーション

1. **Zodを使用**
   - リクエストのバリデーションはZodで定義
   - ドメインエンティティのバリデーションもZodを活用

2. **バリデーションの場所**
   - HTTPリクエスト: Presentation層
   - ビジネスルール: Domain層

## APIドキュメント

### @hono/zod-openapi

このプロジェクトでは、`@hono/zod-openapi`を使用してAPIドキュメントを自動生成しています。

1. **スキーマ定義**
   - DTOはZodスキーマで定義する
   - OpenAPIの仕様に自動変換される

2. **ルート定義**
   - `createRoute()`を使ってOpenAPI対応のルートを定義
   - リクエスト・レスポンスのスキーマを明示的に指定

3. **ドキュメントアクセス**
   - Scalar UI: `http://localhost:8080/api/docs`
   - OpenAPI JSON: `http://localhost:8080/api/openapi.json`

4. **メリット**
   - Zodスキーマから自動生成されるため、常に最新
   - 型安全性が保証される
   - ドキュメントとコードの二重管理が不要
   - インタラクティブなUIでAPIテストが可能

## Git ワークフロー

### コミット前

プリコミットフックが自動実行されます：
- Biomeによるフォーマット・リントチェック（自動修正）
- テストの実行

### コミットメッセージ

分かりやすいコミットメッセージを心がける：
- `feat:` 新機能
- `fix:` バグ修正
- `refactor:` リファクタリング
- `test:` テスト追加・修正
- `docs:` ドキュメント更新

## データベース

### マイグレーション

1. **スキーマ変更時**
   ```bash
   docker compose exec api bun run db:generate
   ```
   - 生成されたマイグレーションファイルを確認
   - 問題なければGitにコミット

2. **マイグレーション実行**
   ```bash
   docker compose exec api bun run db:migrate
   ```

### Drizzle ORM

1. **スキーマ定義**
   - `src/infrastructure/database/drizzle.schema.ts` に定義
   - 型安全性を保つ

2. **クエリ**
   - Drizzleの型安全なクエリビルダーを使用
   - 生SQLは避ける（必要な場合は例外）

3. **Drizzle Studio**
   - 自動でブラウザを開く: `bun run db:studio:open`
   - 手動で起動: `docker compose exec api bun run db:studio`
   - アクセスURL: `https://local.drizzle.studio?port=4984&host=127.0.0.1`
   - 注意: `host=127.0.0.1` を指定しないと接続できない場合があります（サーバーは `--host 0.0.0.0` で起動しますが、ブラウザからは `127.0.0.1` でアクセスします）

## パフォーマンス

1. **N+1問題を避ける**
   - 必要に応じてJOINやeager loadingを使用

2. **適切なインデックス**
   - 頻繁に検索されるカラムにはインデックスを設定

## セキュリティ

1. **バリデーション**
   - ユーザー入力は必ずバリデーションする
   - SQLインジェクション対策（ORMを正しく使用）

2. **機密情報**
   - 環境変数を使用（`.env`ファイル）
   - `.env`は`.gitignore`に含める（既に設定済み）

